============================= test session starts ==============================
platform linux -- Python 3.12.4, pytest-8.2.2, pluggy-1.5.0
rootdir: /home/jks/code/slai-web-pub/project_2
plugins: base-url-2.1.0, playwright-0.5.1
collected 66 items

tests/test_front.py FFFFFFFFFFFFF.FF                                     [ 24%]
tests/test_logic.py FFFFFFFFFFFFF.FF.......F...F...F                     [ 72%]
tests/test_routes.py .FFFFFFFFFFFFFFFFF                                  [100%]

=================================== FAILURES ===================================
_________________________ test_click_button[chromium] __________________________

page = <Page url='http://localhost:5000/'>

    def test_click_button(page: Page):
        """Click a button without selecting any category/language"""
        page.set_default_timeout(TIMEOUT)
        page.goto("http://localhost:5000/")
        page.click("#button_query")
>       assert len(page.query_selector_all("#jokes > p")) == 1
E       AssertionError: assert 0 == 1
E        +  where 0 = len([])
E        +    where [] = <bound method Page.query_selector_all of <Page url='http://localhost:5000/'>>('#jokes > p')
E        +      where <bound method Page.query_selector_all of <Page url='http://localhost:5000/'>> = <Page url='http://localhost:5000/'>.query_selector_all

tests/test_front.py:36: AssertionError
---------------------------- Captured stdout setup -----------------------------
 * Serving Flask app 'joker'
 * Debug mode: off
---------------------------- Captured stderr setup -----------------------------
Address already in use
Port 5000 is in use by another program. Either identify and stop that program, or start the server with a different port.
________________________ test_select_number[chromium-1] ________________________

page = <Page url='http://localhost:5000/'>, number = 1

    @pytest.mark.parametrize("number", [1, 5, 10])
    def test_select_number(page: Page, number):
        """Select different number of jokes"""
        page.set_default_timeout(TIMEOUT)
        page.goto("http://localhost:5000/")
>       page.select_option("#select_number", str(number))

tests/test_front.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../.venv/lib/python3.12/site-packages/playwright/sync_api/_generated.py:10860: in select_option
    self._sync(
../.venv/lib/python3.12/site-packages/playwright/_impl/_page.py:956: in select_option
    return await self._main_frame.select_option(**params)
../.venv/lib/python3.12/site-packages/playwright/_impl/_frame.py:679: in select_option
    return await self._channel.send("selectOption", params)
../.venv/lib/python3.12/site-packages/playwright/_impl/_connection.py:59: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x7f19128e0d40>
cb = <function Channel.send.<locals>.<lambda> at 0x7f19124fe7a0>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.select_option: Timeout 1000ms exceeded.
E           Call log:
E           waiting for locator("#select_number")

../.venv/lib/python3.12/site-packages/playwright/_impl/_connection.py:514: TimeoutError
________________________ test_select_number[chromium-5] ________________________

page = <Page url='http://localhost:5000/'>, number = 5

    @pytest.mark.parametrize("number", [1, 5, 10])
    def test_select_number(page: Page, number):
        """Select different number of jokes"""
        page.set_default_timeout(TIMEOUT)
        page.goto("http://localhost:5000/")
>       page.select_option("#select_number", str(number))

tests/test_front.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../.venv/lib/python3.12/site-packages/playwright/sync_api/_generated.py:10860: in select_option
    self._sync(
../.venv/lib/python3.12/site-packages/playwright/_impl/_page.py:956: in select_option
    return await self._main_frame.select_option(**params)
../.venv/lib/python3.12/site-packages/playwright/_impl/_frame.py:679: in select_option
    return await self._channel.send("selectOption", params)
../.venv/lib/python3.12/site-packages/playwright/_impl/_connection.py:59: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x7f19128e0d40>
cb = <function Channel.send.<locals>.<lambda> at 0x7f19123c47c0>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.select_option: Timeout 1000ms exceeded.
E           Call log:
E           waiting for locator("#select_number")

../.venv/lib/python3.12/site-packages/playwright/_impl/_connection.py:514: TimeoutError
_______________________ test_select_number[chromium-10] ________________________

page = <Page url='http://localhost:5000/'>, number = 10

    @pytest.mark.parametrize("number", [1, 5, 10])
    def test_select_number(page: Page, number):
        """Select different number of jokes"""
        page.set_default_timeout(TIMEOUT)
        page.goto("http://localhost:5000/")
>       page.select_option("#select_number", str(number))

tests/test_front.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../.venv/lib/python3.12/site-packages/playwright/sync_api/_generated.py:10860: in select_option
    self._sync(
../.venv/lib/python3.12/site-packages/playwright/_impl/_page.py:956: in select_option
    return await self._main_frame.select_option(**params)
../.venv/lib/python3.12/site-packages/playwright/_impl/_frame.py:679: in select_option
    return await self._channel.send("selectOption", params)
../.venv/lib/python3.12/site-packages/playwright/_impl/_connection.py:59: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x7f19128e0d40>
cb = <function Channel.send.<locals>.<lambda> at 0x7f19124feac0>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.select_option: Timeout 1000ms exceeded.
E           Call log:
E           waiting for locator("#select_number")

../.venv/lib/python3.12/site-packages/playwright/_impl/_connection.py:514: TimeoutError
______________________ test_select_language[chromium-de] _______________________

page = <Page url='http://localhost:5000/'>, language = 'de'

    @pytest.mark.parametrize("language", ["de", "en", "es", "it"])
    def test_select_language(page: Page, language):
        """Select different languages"""
        page.set_default_timeout(TIMEOUT)
        page.goto("http://localhost:5000/")
        page.select_option("#select_language", language)
        page.click("#button_query")
>       assert len(page.query_selector_all("#jokes > p")) == 1
E       AssertionError: assert 0 == 1
E        +  where 0 = len([])
E        +    where [] = <bound method Page.query_selector_all of <Page url='http://localhost:5000/'>>('#jokes > p')
E        +      where <bound method Page.query_selector_all of <Page url='http://localhost:5000/'>> = <Page url='http://localhost:5000/'>.query_selector_all

tests/test_front.py:56: AssertionError
______________________ test_select_language[chromium-en] _______________________

page = <Page url='http://localhost:5000/'>, language = 'en'

    @pytest.mark.parametrize("language", ["de", "en", "es", "it"])
    def test_select_language(page: Page, language):
        """Select different languages"""
        page.set_default_timeout(TIMEOUT)
        page.goto("http://localhost:5000/")
        page.select_option("#select_language", language)
        page.click("#button_query")
>       assert len(page.query_selector_all("#jokes > p")) == 1
E       AssertionError: assert 0 == 1
E        +  where 0 = len([])
E        +    where [] = <bound method Page.query_selector_all of <Page url='http://localhost:5000/'>>('#jokes > p')
E        +      where <bound method Page.query_selector_all of <Page url='http://localhost:5000/'>> = <Page url='http://localhost:5000/'>.query_selector_all

tests/test_front.py:56: AssertionError
______________________ test_select_language[chromium-es] _______________________

page = <Page url='http://localhost:5000/'>, language = 'es'

    @pytest.mark.parametrize("language", ["de", "en", "es", "it"])
    def test_select_language(page: Page, language):
        """Select different languages"""
        page.set_default_timeout(TIMEOUT)
        page.goto("http://localhost:5000/")
        page.select_option("#select_language", language)
        page.click("#button_query")
>       assert len(page.query_selector_all("#jokes > p")) == 1
E       AssertionError: assert 0 == 1
E        +  where 0 = len([])
E        +    where [] = <bound method Page.query_selector_all of <Page url='http://localhost:5000/'>>('#jokes > p')
E        +      where <bound method Page.query_selector_all of <Page url='http://localhost:5000/'>> = <Page url='http://localhost:5000/'>.query_selector_all

tests/test_front.py:56: AssertionError
______________________ test_select_language[chromium-it] _______________________

page = <Page url='http://localhost:5000/'>, language = 'it'

    @pytest.mark.parametrize("language", ["de", "en", "es", "it"])
    def test_select_language(page: Page, language):
        """Select different languages"""
        page.set_default_timeout(TIMEOUT)
        page.goto("http://localhost:5000/")
        page.select_option("#select_language", language)
        page.click("#button_query")
>       assert len(page.query_selector_all("#jokes > p")) == 1
E       AssertionError: assert 0 == 1
E        +  where 0 = len([])
E        +    where [] = <bound method Page.query_selector_all of <Page url='http://localhost:5000/'>>('#jokes > p')
E        +      where <bound method Page.query_selector_all of <Page url='http://localhost:5000/'>> = <Page url='http://localhost:5000/'>.query_selector_all

tests/test_front.py:56: AssertionError
______________________ test_select_category[chromium-all] ______________________

page = <Page url='http://localhost:5000/'>, category = 'all'

    @pytest.mark.parametrize("category", ["all", "chuck", "neutral"])
    def test_select_category(page: Page, category):
        """Select different categories"""
        page.set_default_timeout(TIMEOUT)
        page.goto("http://localhost:5000/")
        page.select_option("#select_category", category)
        page.click("#button_query")
>       assert len(page.query_selector_all("#jokes > p")) == 1
E       AssertionError: assert 0 == 1
E        +  where 0 = len([])
E        +    where [] = <bound method Page.query_selector_all of <Page url='http://localhost:5000/'>>('#jokes > p')
E        +      where <bound method Page.query_selector_all of <Page url='http://localhost:5000/'>> = <Page url='http://localhost:5000/'>.query_selector_all

tests/test_front.py:66: AssertionError
_____________________ test_select_category[chromium-chuck] _____________________

page = <Page url='http://localhost:5000/'>, category = 'chuck'

    @pytest.mark.parametrize("category", ["all", "chuck", "neutral"])
    def test_select_category(page: Page, category):
        """Select different categories"""
        page.set_default_timeout(TIMEOUT)
        page.goto("http://localhost:5000/")
        page.select_option("#select_category", category)
        page.click("#button_query")
>       assert len(page.query_selector_all("#jokes > p")) == 1
E       AssertionError: assert 0 == 1
E        +  where 0 = len([])
E        +    where [] = <bound method Page.query_selector_all of <Page url='http://localhost:5000/'>>('#jokes > p')
E        +      where <bound method Page.query_selector_all of <Page url='http://localhost:5000/'>> = <Page url='http://localhost:5000/'>.query_selector_all

tests/test_front.py:66: AssertionError
____________________ test_select_category[chromium-neutral] ____________________

page = <Page url='http://localhost:5000/'>, category = 'neutral'

    @pytest.mark.parametrize("category", ["all", "chuck", "neutral"])
    def test_select_category(page: Page, category):
        """Select different categories"""
        page.set_default_timeout(TIMEOUT)
        page.goto("http://localhost:5000/")
        page.select_option("#select_category", category)
        page.click("#button_query")
>       assert len(page.query_selector_all("#jokes > p")) == 1
E       AssertionError: assert 0 == 1
E        +  where 0 = len([])
E        +    where [] = <bound method Page.query_selector_all of <Page url='http://localhost:5000/'>>('#jokes > p')
E        +      where <bound method Page.query_selector_all of <Page url='http://localhost:5000/'>> = <Page url='http://localhost:5000/'>.query_selector_all

tests/test_front.py:66: AssertionError
________________________ test_select_twister[chromium] _________________________

page = <Page url='http://localhost:5000/'>

    def test_select_twister(page: Page):
        """Twisters are only available in German"""
        page.set_default_timeout(TIMEOUT)
        page.goto("http://localhost:5000/")
>       page.select_option("#select_category", "twister")

tests/test_front.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../.venv/lib/python3.12/site-packages/playwright/sync_api/_generated.py:10860: in select_option
    self._sync(
../.venv/lib/python3.12/site-packages/playwright/_impl/_page.py:956: in select_option
    return await self._main_frame.select_option(**params)
../.venv/lib/python3.12/site-packages/playwright/_impl/_frame.py:679: in select_option
    return await self._channel.send("selectOption", params)
../.venv/lib/python3.12/site-packages/playwright/_impl/_connection.py:59: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x7f19128e0d40>
cb = <function Channel.send.<locals>.<lambda> at 0x7f19123f7880>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.select_option: Timeout 1000ms exceeded.
E           Call log:
E           waiting for locator("#select_category")
E             -   locator resolved to <select name="cat" id="select_category">…</select>
E             - attempting select option action
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #1
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #2
E             -   waiting 20ms
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #3
E             -   waiting 100ms
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #4
E             -   waiting 100ms
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #5
E             -   waiting 500ms
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #6
E             -   waiting 500ms

../.venv/lib/python3.12/site-packages/playwright/_impl/_connection.py:514: TimeoutError
______________ test_select_chuck_in_spanish[chromium-en-twister] _______________

page = <Page url='http://localhost:5000/'>, language = 'en'
category = 'twister'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("en", "twister"),
            ("es", "chuck"),
            ("es", "twister"),
            ("it", "twister"),
        ],
    )
    def test_select_chuck_in_spanish(page: Page, language, category):
        """There are no jokes about Chuck Norris in Spanish"""
        page.set_default_timeout(TIMEOUT)
        page.goto("http://localhost:5000/")
>       page.select_option("#select_category", category)

tests/test_front.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../.venv/lib/python3.12/site-packages/playwright/sync_api/_generated.py:10860: in select_option
    self._sync(
../.venv/lib/python3.12/site-packages/playwright/_impl/_page.py:956: in select_option
    return await self._main_frame.select_option(**params)
../.venv/lib/python3.12/site-packages/playwright/_impl/_frame.py:679: in select_option
    return await self._channel.send("selectOption", params)
../.venv/lib/python3.12/site-packages/playwright/_impl/_connection.py:59: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x7f19128e0d40>
cb = <function Channel.send.<locals>.<lambda> at 0x7f19122ef7e0>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.select_option: Timeout 1000ms exceeded.
E           Call log:
E           waiting for locator("#select_category")
E             -   locator resolved to <select name="cat" id="select_category">…</select>
E             - attempting select option action
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #1
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #2
E             -   waiting 20ms
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #3
E             -   waiting 100ms
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #4
E             -   waiting 100ms
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #5
E             -   waiting 500ms
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #6
E             -   waiting 500ms

../.venv/lib/python3.12/site-packages/playwright/_impl/_connection.py:514: TimeoutError
______________ test_select_chuck_in_spanish[chromium-es-twister] _______________

page = <Page url='http://localhost:5000/'>, language = 'es'
category = 'twister'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("en", "twister"),
            ("es", "chuck"),
            ("es", "twister"),
            ("it", "twister"),
        ],
    )
    def test_select_chuck_in_spanish(page: Page, language, category):
        """There are no jokes about Chuck Norris in Spanish"""
        page.set_default_timeout(TIMEOUT)
        page.goto("http://localhost:5000/")
>       page.select_option("#select_category", category)

tests/test_front.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../.venv/lib/python3.12/site-packages/playwright/sync_api/_generated.py:10860: in select_option
    self._sync(
../.venv/lib/python3.12/site-packages/playwright/_impl/_page.py:956: in select_option
    return await self._main_frame.select_option(**params)
../.venv/lib/python3.12/site-packages/playwright/_impl/_frame.py:679: in select_option
    return await self._channel.send("selectOption", params)
../.venv/lib/python3.12/site-packages/playwright/_impl/_connection.py:59: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x7f19128e0d40>
cb = <function Channel.send.<locals>.<lambda> at 0x7f19122ee200>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.select_option: Timeout 1000ms exceeded.
E           Call log:
E           waiting for locator("#select_category")
E             -   locator resolved to <select name="cat" id="select_category">…</select>
E             - attempting select option action
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #1
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #2
E             -   waiting 20ms
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #3
E             -   waiting 100ms
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #4
E             -   waiting 100ms
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #5
E             -   waiting 500ms
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #6
E             -   waiting 500ms

../.venv/lib/python3.12/site-packages/playwright/_impl/_connection.py:514: TimeoutError
______________ test_select_chuck_in_spanish[chromium-it-twister] _______________

page = <Page url='http://localhost:5000/'>, language = 'it'
category = 'twister'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("en", "twister"),
            ("es", "chuck"),
            ("es", "twister"),
            ("it", "twister"),
        ],
    )
    def test_select_chuck_in_spanish(page: Page, language, category):
        """There are no jokes about Chuck Norris in Spanish"""
        page.set_default_timeout(TIMEOUT)
        page.goto("http://localhost:5000/")
>       page.select_option("#select_category", category)

tests/test_front.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../.venv/lib/python3.12/site-packages/playwright/sync_api/_generated.py:10860: in select_option
    self._sync(
../.venv/lib/python3.12/site-packages/playwright/_impl/_page.py:956: in select_option
    return await self._main_frame.select_option(**params)
../.venv/lib/python3.12/site-packages/playwright/_impl/_frame.py:679: in select_option
    return await self._channel.send("selectOption", params)
../.venv/lib/python3.12/site-packages/playwright/_impl/_connection.py:59: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x7f19128e0d40>
cb = <function Channel.send.<locals>.<lambda> at 0x7f19122a4180>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.select_option: Timeout 1000ms exceeded.
E           Call log:
E           waiting for locator("#select_category")
E             -   locator resolved to <select name="cat" id="select_category">…</select>
E             - attempting select option action
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #1
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #2
E             -   waiting 20ms
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #3
E             -   waiting 100ms
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #4
E             -   waiting 100ms
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #5
E             -   waiting 500ms
E             -   waiting for element to be visible and enabled
E             -   did not find some options
E             - retrying select option action, attempt #6
E             -   waiting 500ms

../.venv/lib/python3.12/site-packages/playwright/_impl/_connection.py:514: TimeoutError
______________________________ test_query[de-all] ______________________________

language = 'de', category = 'all'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_query(language, category):
        """Various combinations of language/category should be handled"""
>       assert len(query(language, category)) == 1

tests/test_logic.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

lang = 'de', cat = 'all', num = '1'

    def query(lang: str = "en", cat: str = "all", num: str = "1") -> list[str]:
        """Return a list of jokes
    
        param language: selected language
        param category: selected category
        param number: selected number of jokes
    
        returns: list of random jokes in the chosen language/category with at most `number` of items
        """
        # TODO: Implement this function
        if lang == "es" and cat == "chuck":
            return []
        res = pyjokes.get_jokes(lang, cat)
        random.shuffle(res)
>       return res[0 : min(len(res), num)]
E       TypeError: '<' not supported between instances of 'str' and 'int'

joker/logic.py:21: TypeError
_____________________________ test_query[de-chuck] _____________________________

language = 'de', category = 'chuck'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_query(language, category):
        """Various combinations of language/category should be handled"""
>       assert len(query(language, category)) == 1

tests/test_logic.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

lang = 'de', cat = 'chuck', num = '1'

    def query(lang: str = "en", cat: str = "all", num: str = "1") -> list[str]:
        """Return a list of jokes
    
        param language: selected language
        param category: selected category
        param number: selected number of jokes
    
        returns: list of random jokes in the chosen language/category with at most `number` of items
        """
        # TODO: Implement this function
        if lang == "es" and cat == "chuck":
            return []
        res = pyjokes.get_jokes(lang, cat)
        random.shuffle(res)
>       return res[0 : min(len(res), num)]
E       TypeError: '<' not supported between instances of 'str' and 'int'

joker/logic.py:21: TypeError
____________________________ test_query[de-neutral] ____________________________

language = 'de', category = 'neutral'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_query(language, category):
        """Various combinations of language/category should be handled"""
>       assert len(query(language, category)) == 1

tests/test_logic.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

lang = 'de', cat = 'neutral', num = '1'

    def query(lang: str = "en", cat: str = "all", num: str = "1") -> list[str]:
        """Return a list of jokes
    
        param language: selected language
        param category: selected category
        param number: selected number of jokes
    
        returns: list of random jokes in the chosen language/category with at most `number` of items
        """
        # TODO: Implement this function
        if lang == "es" and cat == "chuck":
            return []
        res = pyjokes.get_jokes(lang, cat)
        random.shuffle(res)
>       return res[0 : min(len(res), num)]
E       TypeError: '<' not supported between instances of 'str' and 'int'

joker/logic.py:21: TypeError
____________________________ test_query[de-twister] ____________________________

language = 'de', category = 'twister'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_query(language, category):
        """Various combinations of language/category should be handled"""
>       assert len(query(language, category)) == 1

tests/test_logic.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

lang = 'de', cat = 'twister', num = '1'

    def query(lang: str = "en", cat: str = "all", num: str = "1") -> list[str]:
        """Return a list of jokes
    
        param language: selected language
        param category: selected category
        param number: selected number of jokes
    
        returns: list of random jokes in the chosen language/category with at most `number` of items
        """
        # TODO: Implement this function
        if lang == "es" and cat == "chuck":
            return []
        res = pyjokes.get_jokes(lang, cat)
        random.shuffle(res)
>       return res[0 : min(len(res), num)]
E       TypeError: '<' not supported between instances of 'str' and 'int'

joker/logic.py:21: TypeError
______________________________ test_query[en-all] ______________________________

language = 'en', category = 'all'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_query(language, category):
        """Various combinations of language/category should be handled"""
>       assert len(query(language, category)) == 1

tests/test_logic.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

lang = 'en', cat = 'all', num = '1'

    def query(lang: str = "en", cat: str = "all", num: str = "1") -> list[str]:
        """Return a list of jokes
    
        param language: selected language
        param category: selected category
        param number: selected number of jokes
    
        returns: list of random jokes in the chosen language/category with at most `number` of items
        """
        # TODO: Implement this function
        if lang == "es" and cat == "chuck":
            return []
        res = pyjokes.get_jokes(lang, cat)
        random.shuffle(res)
>       return res[0 : min(len(res), num)]
E       TypeError: '<' not supported between instances of 'str' and 'int'

joker/logic.py:21: TypeError
_____________________________ test_query[en-chuck] _____________________________

language = 'en', category = 'chuck'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_query(language, category):
        """Various combinations of language/category should be handled"""
>       assert len(query(language, category)) == 1

tests/test_logic.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

lang = 'en', cat = 'chuck', num = '1'

    def query(lang: str = "en", cat: str = "all", num: str = "1") -> list[str]:
        """Return a list of jokes
    
        param language: selected language
        param category: selected category
        param number: selected number of jokes
    
        returns: list of random jokes in the chosen language/category with at most `number` of items
        """
        # TODO: Implement this function
        if lang == "es" and cat == "chuck":
            return []
        res = pyjokes.get_jokes(lang, cat)
        random.shuffle(res)
>       return res[0 : min(len(res), num)]
E       TypeError: '<' not supported between instances of 'str' and 'int'

joker/logic.py:21: TypeError
____________________________ test_query[en-neutral] ____________________________

language = 'en', category = 'neutral'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_query(language, category):
        """Various combinations of language/category should be handled"""
>       assert len(query(language, category)) == 1

tests/test_logic.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

lang = 'en', cat = 'neutral', num = '1'

    def query(lang: str = "en", cat: str = "all", num: str = "1") -> list[str]:
        """Return a list of jokes
    
        param language: selected language
        param category: selected category
        param number: selected number of jokes
    
        returns: list of random jokes in the chosen language/category with at most `number` of items
        """
        # TODO: Implement this function
        if lang == "es" and cat == "chuck":
            return []
        res = pyjokes.get_jokes(lang, cat)
        random.shuffle(res)
>       return res[0 : min(len(res), num)]
E       TypeError: '<' not supported between instances of 'str' and 'int'

joker/logic.py:21: TypeError
______________________________ test_query[es-all] ______________________________

language = 'es', category = 'all'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_query(language, category):
        """Various combinations of language/category should be handled"""
>       assert len(query(language, category)) == 1

tests/test_logic.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

lang = 'es', cat = 'all', num = '1'

    def query(lang: str = "en", cat: str = "all", num: str = "1") -> list[str]:
        """Return a list of jokes
    
        param language: selected language
        param category: selected category
        param number: selected number of jokes
    
        returns: list of random jokes in the chosen language/category with at most `number` of items
        """
        # TODO: Implement this function
        if lang == "es" and cat == "chuck":
            return []
        res = pyjokes.get_jokes(lang, cat)
        random.shuffle(res)
>       return res[0 : min(len(res), num)]
E       TypeError: '<' not supported between instances of 'str' and 'int'

joker/logic.py:21: TypeError
____________________________ test_query[es-neutral] ____________________________

language = 'es', category = 'neutral'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_query(language, category):
        """Various combinations of language/category should be handled"""
>       assert len(query(language, category)) == 1

tests/test_logic.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

lang = 'es', cat = 'neutral', num = '1'

    def query(lang: str = "en", cat: str = "all", num: str = "1") -> list[str]:
        """Return a list of jokes
    
        param language: selected language
        param category: selected category
        param number: selected number of jokes
    
        returns: list of random jokes in the chosen language/category with at most `number` of items
        """
        # TODO: Implement this function
        if lang == "es" and cat == "chuck":
            return []
        res = pyjokes.get_jokes(lang, cat)
        random.shuffle(res)
>       return res[0 : min(len(res), num)]
E       TypeError: '<' not supported between instances of 'str' and 'int'

joker/logic.py:21: TypeError
______________________________ test_query[it-all] ______________________________

language = 'it', category = 'all'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_query(language, category):
        """Various combinations of language/category should be handled"""
>       assert len(query(language, category)) == 1

tests/test_logic.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

lang = 'it', cat = 'all', num = '1'

    def query(lang: str = "en", cat: str = "all", num: str = "1") -> list[str]:
        """Return a list of jokes
    
        param language: selected language
        param category: selected category
        param number: selected number of jokes
    
        returns: list of random jokes in the chosen language/category with at most `number` of items
        """
        # TODO: Implement this function
        if lang == "es" and cat == "chuck":
            return []
        res = pyjokes.get_jokes(lang, cat)
        random.shuffle(res)
>       return res[0 : min(len(res), num)]
E       TypeError: '<' not supported between instances of 'str' and 'int'

joker/logic.py:21: TypeError
_____________________________ test_query[it-chuck] _____________________________

language = 'it', category = 'chuck'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_query(language, category):
        """Various combinations of language/category should be handled"""
>       assert len(query(language, category)) == 1

tests/test_logic.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

lang = 'it', cat = 'chuck', num = '1'

    def query(lang: str = "en", cat: str = "all", num: str = "1") -> list[str]:
        """Return a list of jokes
    
        param language: selected language
        param category: selected category
        param number: selected number of jokes
    
        returns: list of random jokes in the chosen language/category with at most `number` of items
        """
        # TODO: Implement this function
        if lang == "es" and cat == "chuck":
            return []
        res = pyjokes.get_jokes(lang, cat)
        random.shuffle(res)
>       return res[0 : min(len(res), num)]
E       TypeError: '<' not supported between instances of 'str' and 'int'

joker/logic.py:21: TypeError
____________________________ test_query[it-neutral] ____________________________

language = 'it', category = 'neutral'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_query(language, category):
        """Various combinations of language/category should be handled"""
>       assert len(query(language, category)) == 1

tests/test_logic.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

lang = 'it', cat = 'neutral', num = '1'

    def query(lang: str = "en", cat: str = "all", num: str = "1") -> list[str]:
        """Return a list of jokes
    
        param language: selected language
        param category: selected category
        param number: selected number of jokes
    
        returns: list of random jokes in the chosen language/category with at most `number` of items
        """
        # TODO: Implement this function
        if lang == "es" and cat == "chuck":
            return []
        res = pyjokes.get_jokes(lang, cat)
        random.shuffle(res)
>       return res[0 : min(len(res), num)]
E       TypeError: '<' not supported between instances of 'str' and 'int'

joker/logic.py:21: TypeError
_________________________ test_query_error[en-twister] _________________________

language = 'en', category = 'twister'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("en", "twister"),
            ("es", "chuck"),
            ("es", "twister"),
            ("it", "twister"),
        ],
    )
    def test_query_error(language, category):
        """Not all combinations are valid"""
>       assert len(query(language, category)) == 0

tests/test_logic.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
joker/logic.py:19: in query
    res = pyjokes.get_jokes(lang, cat)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

language = 'en', category = 'twister'

    def get_jokes(language='en', category='neutral'):
        """
        Parameters
        ----------
        category: str
            Choices: 'neutral', 'chuck', 'all', 'twister'
        lang: str
            Choices: 'en', 'de', 'es', 'gl', 'eu', 'it'
    
        Returns
        -------
        jokes: list
        """
    
        if language not in all_jokes:
            raise LanguageNotFoundError('No such language %s' % language)
    
        jokes = all_jokes[language]
    
        if category not in jokes:
>           raise CategoryNotFoundError('No such category %s in language %s' % (category, language))
E           pyjokes.pyjokes.CategoryNotFoundError: No such category twister in language en

../.venv/lib/python3.12/site-packages/pyjokes/pyjokes.py:49: CategoryNotFoundError
_________________________ test_query_error[es-twister] _________________________

language = 'es', category = 'twister'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("en", "twister"),
            ("es", "chuck"),
            ("es", "twister"),
            ("it", "twister"),
        ],
    )
    def test_query_error(language, category):
        """Not all combinations are valid"""
>       assert len(query(language, category)) == 0

tests/test_logic.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
joker/logic.py:19: in query
    res = pyjokes.get_jokes(lang, cat)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

language = 'es', category = 'twister'

    def get_jokes(language='en', category='neutral'):
        """
        Parameters
        ----------
        category: str
            Choices: 'neutral', 'chuck', 'all', 'twister'
        lang: str
            Choices: 'en', 'de', 'es', 'gl', 'eu', 'it'
    
        Returns
        -------
        jokes: list
        """
    
        if language not in all_jokes:
            raise LanguageNotFoundError('No such language %s' % language)
    
        jokes = all_jokes[language]
    
        if category not in jokes:
>           raise CategoryNotFoundError('No such category %s in language %s' % (category, language))
E           pyjokes.pyjokes.CategoryNotFoundError: No such category twister in language es

../.venv/lib/python3.12/site-packages/pyjokes/pyjokes.py:49: CategoryNotFoundError
_________________________ test_query_error[it-twister] _________________________

language = 'it', category = 'twister'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("en", "twister"),
            ("es", "chuck"),
            ("es", "twister"),
            ("it", "twister"),
        ],
    )
    def test_query_error(language, category):
        """Not all combinations are valid"""
>       assert len(query(language, category)) == 0

tests/test_logic.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
joker/logic.py:19: in query
    res = pyjokes.get_jokes(lang, cat)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

language = 'it', category = 'twister'

    def get_jokes(language='en', category='neutral'):
        """
        Parameters
        ----------
        category: str
            Choices: 'neutral', 'chuck', 'all', 'twister'
        lang: str
            Choices: 'en', 'de', 'es', 'gl', 'eu', 'it'
    
        Returns
        -------
        jokes: list
        """
    
        if language not in all_jokes:
            raise LanguageNotFoundError('No such language %s' % language)
    
        jokes = all_jokes[language]
    
        if category not in jokes:
>           raise CategoryNotFoundError('No such category %s in language %s' % (category, language))
E           pyjokes.pyjokes.CategoryNotFoundError: No such category twister in language it

../.venv/lib/python3.12/site-packages/pyjokes/pyjokes.py:49: CategoryNotFoundError
_______________________ test_query_number[en-twister-0] ________________________

language = 'en', category = 'twister', number = 0

    @pytest.mark.parametrize(
        "language, category, number",
        [
            ("de", "all", 146),
            ("de", "chuck", 68),
            ("de", "neutral", 59),
            ("de", "twister", 19),
            ("en", "all", 200),
            ("en", "chuck", 103),
            ("en", "neutral", 97),
            ("en", "twister", 0),
            ("es", "all", 14),
            ("es", "chuck", 0),
            ("es", "neutral", 14),
            ("es", "twister", 0),
            ("it", "all", 159),
            ("it", "chuck", 87),
            ("it", "neutral", 72),
            ("it", "twister", 0),
        ],
    )
    def test_query_number(language, category, number):
        """
        There is a limited number of jokes in each category/language.
        Requesting infinity (sys.maxsize) should return all jokes of that combination
        """
>       assert len(query(language, category, sys.maxsize)) == number

tests/test_logic.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
joker/logic.py:19: in query
    res = pyjokes.get_jokes(lang, cat)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

language = 'en', category = 'twister'

    def get_jokes(language='en', category='neutral'):
        """
        Parameters
        ----------
        category: str
            Choices: 'neutral', 'chuck', 'all', 'twister'
        lang: str
            Choices: 'en', 'de', 'es', 'gl', 'eu', 'it'
    
        Returns
        -------
        jokes: list
        """
    
        if language not in all_jokes:
            raise LanguageNotFoundError('No such language %s' % language)
    
        jokes = all_jokes[language]
    
        if category not in jokes:
>           raise CategoryNotFoundError('No such category %s in language %s' % (category, language))
E           pyjokes.pyjokes.CategoryNotFoundError: No such category twister in language en

../.venv/lib/python3.12/site-packages/pyjokes/pyjokes.py:49: CategoryNotFoundError
_______________________ test_query_number[es-twister-0] ________________________

language = 'es', category = 'twister', number = 0

    @pytest.mark.parametrize(
        "language, category, number",
        [
            ("de", "all", 146),
            ("de", "chuck", 68),
            ("de", "neutral", 59),
            ("de", "twister", 19),
            ("en", "all", 200),
            ("en", "chuck", 103),
            ("en", "neutral", 97),
            ("en", "twister", 0),
            ("es", "all", 14),
            ("es", "chuck", 0),
            ("es", "neutral", 14),
            ("es", "twister", 0),
            ("it", "all", 159),
            ("it", "chuck", 87),
            ("it", "neutral", 72),
            ("it", "twister", 0),
        ],
    )
    def test_query_number(language, category, number):
        """
        There is a limited number of jokes in each category/language.
        Requesting infinity (sys.maxsize) should return all jokes of that combination
        """
>       assert len(query(language, category, sys.maxsize)) == number

tests/test_logic.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
joker/logic.py:19: in query
    res = pyjokes.get_jokes(lang, cat)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

language = 'es', category = 'twister'

    def get_jokes(language='en', category='neutral'):
        """
        Parameters
        ----------
        category: str
            Choices: 'neutral', 'chuck', 'all', 'twister'
        lang: str
            Choices: 'en', 'de', 'es', 'gl', 'eu', 'it'
    
        Returns
        -------
        jokes: list
        """
    
        if language not in all_jokes:
            raise LanguageNotFoundError('No such language %s' % language)
    
        jokes = all_jokes[language]
    
        if category not in jokes:
>           raise CategoryNotFoundError('No such category %s in language %s' % (category, language))
E           pyjokes.pyjokes.CategoryNotFoundError: No such category twister in language es

../.venv/lib/python3.12/site-packages/pyjokes/pyjokes.py:49: CategoryNotFoundError
_______________________ test_query_number[it-twister-0] ________________________

language = 'it', category = 'twister', number = 0

    @pytest.mark.parametrize(
        "language, category, number",
        [
            ("de", "all", 146),
            ("de", "chuck", 68),
            ("de", "neutral", 59),
            ("de", "twister", 19),
            ("en", "all", 200),
            ("en", "chuck", 103),
            ("en", "neutral", 97),
            ("en", "twister", 0),
            ("es", "all", 14),
            ("es", "chuck", 0),
            ("es", "neutral", 14),
            ("es", "twister", 0),
            ("it", "all", 159),
            ("it", "chuck", 87),
            ("it", "neutral", 72),
            ("it", "twister", 0),
        ],
    )
    def test_query_number(language, category, number):
        """
        There is a limited number of jokes in each category/language.
        Requesting infinity (sys.maxsize) should return all jokes of that combination
        """
>       assert len(query(language, category, sys.maxsize)) == number

tests/test_logic.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
joker/logic.py:19: in query
    res = pyjokes.get_jokes(lang, cat)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

language = 'it', category = 'twister'

    def get_jokes(language='en', category='neutral'):
        """
        Parameters
        ----------
        category: str
            Choices: 'neutral', 'chuck', 'all', 'twister'
        lang: str
            Choices: 'en', 'de', 'es', 'gl', 'eu', 'it'
    
        Returns
        -------
        jokes: list
        """
    
        if language not in all_jokes:
            raise LanguageNotFoundError('No such language %s' % language)
    
        jokes = all_jokes[language]
    
        if category not in jokes:
>           raise CategoryNotFoundError('No such category %s in language %s' % (category, language))
E           pyjokes.pyjokes.CategoryNotFoundError: No such category twister in language it

../.venv/lib/python3.12/site-packages/pyjokes/pyjokes.py:49: CategoryNotFoundError
_______________________________ test_index_post ________________________________

client = <FlaskClient <Flask 'joker'>>

    def test_index_post(client):
        """POST without any data should trigger query defaults"""
>       assert client.post("/").status_code == 200
E       AssertionError: assert 400 == 200
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
E        +    where <WrapperTestResponse streamed [400 BAD REQUEST]> = <bound method Client.post of <FlaskClient <Flask 'joker'>>>('/')
E        +      where <bound method Client.post of <FlaskClient <Flask 'joker'>>> = <FlaskClient <Flask 'joker'>>.post

tests/test_routes.py:19: AssertionError
_________________________ test_form_post_valid[de-all] _________________________

client = <FlaskClient <Flask 'joker'>>, language = 'de', category = 'all'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_form_post_valid(client, language, category):
        """Various combinations of language/category should be handled"""
>       assert (
            client.post("/", data=dict(language=language, category=category)).status_code
            == 200
        )
E       AssertionError: assert 400 == 200
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
E        +    where <WrapperTestResponse streamed [400 BAD REQUEST]> = <bound method Client.post of <FlaskClient <Flask 'joker'>>>('/', data={'category': 'all', 'language': 'de'})
E        +      where <bound method Client.post of <FlaskClient <Flask 'joker'>>> = <FlaskClient <Flask 'joker'>>.post
E        +      and   {'category': 'all', 'language': 'de'} = dict(language='de', category='all')

tests/test_routes.py:41: AssertionError
________________________ test_form_post_valid[de-chuck] ________________________

client = <FlaskClient <Flask 'joker'>>, language = 'de', category = 'chuck'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_form_post_valid(client, language, category):
        """Various combinations of language/category should be handled"""
>       assert (
            client.post("/", data=dict(language=language, category=category)).status_code
            == 200
        )
E       AssertionError: assert 400 == 200
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
E        +    where <WrapperTestResponse streamed [400 BAD REQUEST]> = <bound method Client.post of <FlaskClient <Flask 'joker'>>>('/', data={'category': 'chuck', 'language': 'de'})
E        +      where <bound method Client.post of <FlaskClient <Flask 'joker'>>> = <FlaskClient <Flask 'joker'>>.post
E        +      and   {'category': 'chuck', 'language': 'de'} = dict(language='de', category='chuck')

tests/test_routes.py:41: AssertionError
_______________________ test_form_post_valid[de-neutral] _______________________

client = <FlaskClient <Flask 'joker'>>, language = 'de', category = 'neutral'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_form_post_valid(client, language, category):
        """Various combinations of language/category should be handled"""
>       assert (
            client.post("/", data=dict(language=language, category=category)).status_code
            == 200
        )
E       AssertionError: assert 400 == 200
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
E        +    where <WrapperTestResponse streamed [400 BAD REQUEST]> = <bound method Client.post of <FlaskClient <Flask 'joker'>>>('/', data={'category': 'neutral', 'language': 'de'})
E        +      where <bound method Client.post of <FlaskClient <Flask 'joker'>>> = <FlaskClient <Flask 'joker'>>.post
E        +      and   {'category': 'neutral', 'language': 'de'} = dict(language='de', category='neutral')

tests/test_routes.py:41: AssertionError
_______________________ test_form_post_valid[de-twister] _______________________

client = <FlaskClient <Flask 'joker'>>, language = 'de', category = 'twister'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_form_post_valid(client, language, category):
        """Various combinations of language/category should be handled"""
>       assert (
            client.post("/", data=dict(language=language, category=category)).status_code
            == 200
        )
E       AssertionError: assert 400 == 200
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
E        +    where <WrapperTestResponse streamed [400 BAD REQUEST]> = <bound method Client.post of <FlaskClient <Flask 'joker'>>>('/', data={'category': 'twister', 'language': 'de'})
E        +      where <bound method Client.post of <FlaskClient <Flask 'joker'>>> = <FlaskClient <Flask 'joker'>>.post
E        +      and   {'category': 'twister', 'language': 'de'} = dict(language='de', category='twister')

tests/test_routes.py:41: AssertionError
_________________________ test_form_post_valid[en-all] _________________________

client = <FlaskClient <Flask 'joker'>>, language = 'en', category = 'all'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_form_post_valid(client, language, category):
        """Various combinations of language/category should be handled"""
>       assert (
            client.post("/", data=dict(language=language, category=category)).status_code
            == 200
        )
E       AssertionError: assert 400 == 200
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
E        +    where <WrapperTestResponse streamed [400 BAD REQUEST]> = <bound method Client.post of <FlaskClient <Flask 'joker'>>>('/', data={'category': 'all', 'language': 'en'})
E        +      where <bound method Client.post of <FlaskClient <Flask 'joker'>>> = <FlaskClient <Flask 'joker'>>.post
E        +      and   {'category': 'all', 'language': 'en'} = dict(language='en', category='all')

tests/test_routes.py:41: AssertionError
________________________ test_form_post_valid[en-chuck] ________________________

client = <FlaskClient <Flask 'joker'>>, language = 'en', category = 'chuck'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_form_post_valid(client, language, category):
        """Various combinations of language/category should be handled"""
>       assert (
            client.post("/", data=dict(language=language, category=category)).status_code
            == 200
        )
E       AssertionError: assert 400 == 200
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
E        +    where <WrapperTestResponse streamed [400 BAD REQUEST]> = <bound method Client.post of <FlaskClient <Flask 'joker'>>>('/', data={'category': 'chuck', 'language': 'en'})
E        +      where <bound method Client.post of <FlaskClient <Flask 'joker'>>> = <FlaskClient <Flask 'joker'>>.post
E        +      and   {'category': 'chuck', 'language': 'en'} = dict(language='en', category='chuck')

tests/test_routes.py:41: AssertionError
_______________________ test_form_post_valid[en-neutral] _______________________

client = <FlaskClient <Flask 'joker'>>, language = 'en', category = 'neutral'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_form_post_valid(client, language, category):
        """Various combinations of language/category should be handled"""
>       assert (
            client.post("/", data=dict(language=language, category=category)).status_code
            == 200
        )
E       AssertionError: assert 400 == 200
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
E        +    where <WrapperTestResponse streamed [400 BAD REQUEST]> = <bound method Client.post of <FlaskClient <Flask 'joker'>>>('/', data={'category': 'neutral', 'language': 'en'})
E        +      where <bound method Client.post of <FlaskClient <Flask 'joker'>>> = <FlaskClient <Flask 'joker'>>.post
E        +      and   {'category': 'neutral', 'language': 'en'} = dict(language='en', category='neutral')

tests/test_routes.py:41: AssertionError
_________________________ test_form_post_valid[es-all] _________________________

client = <FlaskClient <Flask 'joker'>>, language = 'es', category = 'all'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_form_post_valid(client, language, category):
        """Various combinations of language/category should be handled"""
>       assert (
            client.post("/", data=dict(language=language, category=category)).status_code
            == 200
        )
E       AssertionError: assert 400 == 200
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
E        +    where <WrapperTestResponse streamed [400 BAD REQUEST]> = <bound method Client.post of <FlaskClient <Flask 'joker'>>>('/', data={'category': 'all', 'language': 'es'})
E        +      where <bound method Client.post of <FlaskClient <Flask 'joker'>>> = <FlaskClient <Flask 'joker'>>.post
E        +      and   {'category': 'all', 'language': 'es'} = dict(language='es', category='all')

tests/test_routes.py:41: AssertionError
_______________________ test_form_post_valid[es-neutral] _______________________

client = <FlaskClient <Flask 'joker'>>, language = 'es', category = 'neutral'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_form_post_valid(client, language, category):
        """Various combinations of language/category should be handled"""
>       assert (
            client.post("/", data=dict(language=language, category=category)).status_code
            == 200
        )
E       AssertionError: assert 400 == 200
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
E        +    where <WrapperTestResponse streamed [400 BAD REQUEST]> = <bound method Client.post of <FlaskClient <Flask 'joker'>>>('/', data={'category': 'neutral', 'language': 'es'})
E        +      where <bound method Client.post of <FlaskClient <Flask 'joker'>>> = <FlaskClient <Flask 'joker'>>.post
E        +      and   {'category': 'neutral', 'language': 'es'} = dict(language='es', category='neutral')

tests/test_routes.py:41: AssertionError
_________________________ test_form_post_valid[it-all] _________________________

client = <FlaskClient <Flask 'joker'>>, language = 'it', category = 'all'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_form_post_valid(client, language, category):
        """Various combinations of language/category should be handled"""
>       assert (
            client.post("/", data=dict(language=language, category=category)).status_code
            == 200
        )
E       AssertionError: assert 400 == 200
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
E        +    where <WrapperTestResponse streamed [400 BAD REQUEST]> = <bound method Client.post of <FlaskClient <Flask 'joker'>>>('/', data={'category': 'all', 'language': 'it'})
E        +      where <bound method Client.post of <FlaskClient <Flask 'joker'>>> = <FlaskClient <Flask 'joker'>>.post
E        +      and   {'category': 'all', 'language': 'it'} = dict(language='it', category='all')

tests/test_routes.py:41: AssertionError
________________________ test_form_post_valid[it-chuck] ________________________

client = <FlaskClient <Flask 'joker'>>, language = 'it', category = 'chuck'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_form_post_valid(client, language, category):
        """Various combinations of language/category should be handled"""
>       assert (
            client.post("/", data=dict(language=language, category=category)).status_code
            == 200
        )
E       AssertionError: assert 400 == 200
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
E        +    where <WrapperTestResponse streamed [400 BAD REQUEST]> = <bound method Client.post of <FlaskClient <Flask 'joker'>>>('/', data={'category': 'chuck', 'language': 'it'})
E        +      where <bound method Client.post of <FlaskClient <Flask 'joker'>>> = <FlaskClient <Flask 'joker'>>.post
E        +      and   {'category': 'chuck', 'language': 'it'} = dict(language='it', category='chuck')

tests/test_routes.py:41: AssertionError
_______________________ test_form_post_valid[it-neutral] _______________________

client = <FlaskClient <Flask 'joker'>>, language = 'it', category = 'neutral'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("de", "all"),
            ("de", "chuck"),
            ("de", "neutral"),
            ("de", "twister"),
            ("en", "all"),
            ("en", "chuck"),
            ("en", "neutral"),
            ("es", "all"),
            ("es", "neutral"),
            ("it", "all"),
            ("it", "chuck"),
            ("it", "neutral"),
        ],
    )
    def test_form_post_valid(client, language, category):
        """Various combinations of language/category should be handled"""
>       assert (
            client.post("/", data=dict(language=language, category=category)).status_code
            == 200
        )
E       AssertionError: assert 400 == 200
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
E        +    where <WrapperTestResponse streamed [400 BAD REQUEST]> = <bound method Client.post of <FlaskClient <Flask 'joker'>>>('/', data={'category': 'neutral', 'language': 'it'})
E        +      where <bound method Client.post of <FlaskClient <Flask 'joker'>>> = <FlaskClient <Flask 'joker'>>.post
E        +      and   {'category': 'neutral', 'language': 'it'} = dict(language='it', category='neutral')

tests/test_routes.py:41: AssertionError
_______________________ test_form_post_error[en-twister] _______________________

client = <FlaskClient <Flask 'joker'>>, language = 'en', category = 'twister'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("en", "twister"),
            ("es", "chuck"),
            ("es", "twister"),
            ("it", "twister"),
        ],
    )
    def test_form_post_error(client, language, category):
        """Various combinations of language/category should be handled"""
>       assert (
            client.post("/", data=dict(language=language, category=category)).status_code
            == 404
        )
E       AssertionError: assert 400 == 404
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
E        +    where <WrapperTestResponse streamed [400 BAD REQUEST]> = <bound method Client.post of <FlaskClient <Flask 'joker'>>>('/', data={'category': 'twister', 'language': 'en'})
E        +      where <bound method Client.post of <FlaskClient <Flask 'joker'>>> = <FlaskClient <Flask 'joker'>>.post
E        +      and   {'category': 'twister', 'language': 'en'} = dict(language='en', category='twister')

tests/test_routes.py:58: AssertionError
________________________ test_form_post_error[es-chuck] ________________________

client = <FlaskClient <Flask 'joker'>>, language = 'es', category = 'chuck'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("en", "twister"),
            ("es", "chuck"),
            ("es", "twister"),
            ("it", "twister"),
        ],
    )
    def test_form_post_error(client, language, category):
        """Various combinations of language/category should be handled"""
>       assert (
            client.post("/", data=dict(language=language, category=category)).status_code
            == 404
        )
E       AssertionError: assert 400 == 404
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
E        +    where <WrapperTestResponse streamed [400 BAD REQUEST]> = <bound method Client.post of <FlaskClient <Flask 'joker'>>>('/', data={'category': 'chuck', 'language': 'es'})
E        +      where <bound method Client.post of <FlaskClient <Flask 'joker'>>> = <FlaskClient <Flask 'joker'>>.post
E        +      and   {'category': 'chuck', 'language': 'es'} = dict(language='es', category='chuck')

tests/test_routes.py:58: AssertionError
_______________________ test_form_post_error[es-twister] _______________________

client = <FlaskClient <Flask 'joker'>>, language = 'es', category = 'twister'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("en", "twister"),
            ("es", "chuck"),
            ("es", "twister"),
            ("it", "twister"),
        ],
    )
    def test_form_post_error(client, language, category):
        """Various combinations of language/category should be handled"""
>       assert (
            client.post("/", data=dict(language=language, category=category)).status_code
            == 404
        )
E       AssertionError: assert 400 == 404
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
E        +    where <WrapperTestResponse streamed [400 BAD REQUEST]> = <bound method Client.post of <FlaskClient <Flask 'joker'>>>('/', data={'category': 'twister', 'language': 'es'})
E        +      where <bound method Client.post of <FlaskClient <Flask 'joker'>>> = <FlaskClient <Flask 'joker'>>.post
E        +      and   {'category': 'twister', 'language': 'es'} = dict(language='es', category='twister')

tests/test_routes.py:58: AssertionError
_______________________ test_form_post_error[it-twister] _______________________

client = <FlaskClient <Flask 'joker'>>, language = 'it', category = 'twister'

    @pytest.mark.parametrize(
        "language, category",
        [
            ("en", "twister"),
            ("es", "chuck"),
            ("es", "twister"),
            ("it", "twister"),
        ],
    )
    def test_form_post_error(client, language, category):
        """Various combinations of language/category should be handled"""
>       assert (
            client.post("/", data=dict(language=language, category=category)).status_code
            == 404
        )
E       AssertionError: assert 400 == 404
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
E        +    where <WrapperTestResponse streamed [400 BAD REQUEST]> = <bound method Client.post of <FlaskClient <Flask 'joker'>>>('/', data={'category': 'twister', 'language': 'it'})
E        +      where <bound method Client.post of <FlaskClient <Flask 'joker'>>> = <FlaskClient <Flask 'joker'>>.post
E        +      and   {'category': 'twister', 'language': 'it'} = dict(language='it', category='twister')

tests/test_routes.py:58: AssertionError
=========================== short test summary info ============================
FAILED tests/test_front.py::test_click_button[chromium] - AssertionError: ass...
FAILED tests/test_front.py::test_select_number[chromium-1] - playwright._impl...
FAILED tests/test_front.py::test_select_number[chromium-5] - playwright._impl...
FAILED tests/test_front.py::test_select_number[chromium-10] - playwright._imp...
FAILED tests/test_front.py::test_select_language[chromium-de] - AssertionErro...
FAILED tests/test_front.py::test_select_language[chromium-en] - AssertionErro...
FAILED tests/test_front.py::test_select_language[chromium-es] - AssertionErro...
FAILED tests/test_front.py::test_select_language[chromium-it] - AssertionErro...
FAILED tests/test_front.py::test_select_category[chromium-all] - AssertionErr...
FAILED tests/test_front.py::test_select_category[chromium-chuck] - AssertionE...
FAILED tests/test_front.py::test_select_category[chromium-neutral] - Assertio...
FAILED tests/test_front.py::test_select_twister[chromium] - playwright._impl....
FAILED tests/test_front.py::test_select_chuck_in_spanish[chromium-en-twister]
FAILED tests/test_front.py::test_select_chuck_in_spanish[chromium-es-twister]
FAILED tests/test_front.py::test_select_chuck_in_spanish[chromium-it-twister]
FAILED tests/test_logic.py::test_query[de-all] - TypeError: '<' not supported...
FAILED tests/test_logic.py::test_query[de-chuck] - TypeError: '<' not support...
FAILED tests/test_logic.py::test_query[de-neutral] - TypeError: '<' not suppo...
FAILED tests/test_logic.py::test_query[de-twister] - TypeError: '<' not suppo...
FAILED tests/test_logic.py::test_query[en-all] - TypeError: '<' not supported...
FAILED tests/test_logic.py::test_query[en-chuck] - TypeError: '<' not support...
FAILED tests/test_logic.py::test_query[en-neutral] - TypeError: '<' not suppo...
FAILED tests/test_logic.py::test_query[es-all] - TypeError: '<' not supported...
FAILED tests/test_logic.py::test_query[es-neutral] - TypeError: '<' not suppo...
FAILED tests/test_logic.py::test_query[it-all] - TypeError: '<' not supported...
FAILED tests/test_logic.py::test_query[it-chuck] - TypeError: '<' not support...
FAILED tests/test_logic.py::test_query[it-neutral] - TypeError: '<' not suppo...
FAILED tests/test_logic.py::test_query_error[en-twister] - pyjokes.pyjokes.Ca...
FAILED tests/test_logic.py::test_query_error[es-twister] - pyjokes.pyjokes.Ca...
FAILED tests/test_logic.py::test_query_error[it-twister] - pyjokes.pyjokes.Ca...
FAILED tests/test_logic.py::test_query_number[en-twister-0] - pyjokes.pyjokes...
FAILED tests/test_logic.py::test_query_number[es-twister-0] - pyjokes.pyjokes...
FAILED tests/test_logic.py::test_query_number[it-twister-0] - pyjokes.pyjokes...
FAILED tests/test_routes.py::test_index_post - AssertionError: assert 400 == 200
FAILED tests/test_routes.py::test_form_post_valid[de-all] - AssertionError: a...
FAILED tests/test_routes.py::test_form_post_valid[de-chuck] - AssertionError:...
FAILED tests/test_routes.py::test_form_post_valid[de-neutral] - AssertionErro...
FAILED tests/test_routes.py::test_form_post_valid[de-twister] - AssertionErro...
FAILED tests/test_routes.py::test_form_post_valid[en-all] - AssertionError: a...
FAILED tests/test_routes.py::test_form_post_valid[en-chuck] - AssertionError:...
FAILED tests/test_routes.py::test_form_post_valid[en-neutral] - AssertionErro...
FAILED tests/test_routes.py::test_form_post_valid[es-all] - AssertionError: a...
FAILED tests/test_routes.py::test_form_post_valid[es-neutral] - AssertionErro...
FAILED tests/test_routes.py::test_form_post_valid[it-all] - AssertionError: a...
FAILED tests/test_routes.py::test_form_post_valid[it-chuck] - AssertionError:...
FAILED tests/test_routes.py::test_form_post_valid[it-neutral] - AssertionErro...
FAILED tests/test_routes.py::test_form_post_error[en-twister] - AssertionErro...
FAILED tests/test_routes.py::test_form_post_error[es-chuck] - AssertionError:...
FAILED tests/test_routes.py::test_form_post_error[es-twister] - AssertionErro...
FAILED tests/test_routes.py::test_form_post_error[it-twister] - AssertionErro...
======================== 50 failed, 16 passed in 11.59s ========================
